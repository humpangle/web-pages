<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html style><!--
 Page saved with SingleFile
 url: http://lua-users.org/wiki/SplitJoin
 saved date: Fri Apr 23 2021 22:43:32 GMT+0200 (Central European Summer Time)
--><meta charset=utf-8><title>lua-users wiki: Split Join</title>
<style>BODY{background:white;color:navy}A:link{color:#DF6C00}A:active,A:visited{color:maroon}a.nav{text-decoration:none;color:navy;font-weight:bold;font-family:Arial,sans-serif;font-size:22px}pre.code{color:black}span.comment{color:#00a000}span.string{color:#009090}span.keyword{color:navy;font-weight:bold}span.library{color:#900090}dd pre.code{border-left:1px dotted maroon;margin-left:-1em;padding-left:1em}body{line-height:1.25;margin:0px auto;padding:16px;max-width:70em;width:95%}h1,h2,h3{font-family:Verdana,Geneva,sans-serif;font-weight:normal;font-style:normal;text-align:left}</style>
<link type=image/x-icon rel="shortcut icon" href="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><link rel=canonical href=http://lua-users.org/wiki/SplitJoin></head>
<body><table width=100% border=0> <tbody><tr><td align=left width=100%><h1><a href="http://lua-users.org/cgi-bin/wiki.pl?action=search&amp;string=SplitJoin&amp;body=1" title="List pages referring to SplitJoin">Split Join</a></h1><td align=right>
 <table cellpadding=0 cellspacing=0 border=0 width=1%>
 <tbody>
 <tr>
 <td><a href=http://lua-users.org/>
 <img src=data:image/png;base64,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 alt="lua-users home" width=177 height=40 border=0></a></td>
 </tr>
 <tr>
 <td>
 <table cellpadding=0 cellspacing=0 border=0 width=100%>
 <tbody>
 <tr>
 <td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAoCAYAAAC4h3lxAAAACXBIWXMAAAsSAAALEgHS3X78AAAAhklEQVR42u3TsQmAQAyF4SgnWp0DiPM4iPM4hbO4hmB1pYJgY/Gs7e+Ew/+VKZJ8gZgip+smhXDqq5SWeQAAAAAAAAAAAAAAAAAg27jYDSXZth12XXf0ZauqtL5vX7VCkmIOGYbZ1nVPcu2mcbYso3lfpwPwAwAAAAAAAAAAAAAAAADwF8ADzh3T/PxicksAAAAASUVORK5CYII=" alt width=48 height=40></td>
 <td nowrap valign=middle width=100%>
 <a href=http://lua-users.org/wiki/ class=nav>wiki</a></td>
 </tr>
 </tbody>
 </table>
 </td>
 </tr>
 </tbody>
 </table>
<form method=post action=/wiki/FindPage enctype=application/x-www-form-urlencoded style=display:inline;margin:0>
<input type=text name=string size=20 id=search_query1 value><input type=submit name=.submit value=Search></form></tr> </table>
<br clear=all>
"split" <a href=http://en.wikipedia.org/wiki/String_manipulation_algorithm#split>[1]</a> and "join"<a href=http://en.wikipedia.org/wiki/Comparison_of_programming_languages_%28string_functions%29#join>[2]</a> are two common string operators that are essentially inverse operations of each other. Split separates a string containing a delimiter into the list of substrings between that delimiter. Join combines a list of strings into a new string by inserting a delimiter between each string.
<p>
There are various ways to design and implement these functions in Lua, as described below.
<p>
<hr><h2>Joining list of strings</h2>
<p>
With Lua 5.x you can use
table.concat<a href=http://www.lua.org/manual/5.1/manual.html#pdf-table.concat>[3]</a> for
joining: <code>table.concat(tbl, delimiter_str)</code>.
<p>
<dl>
<dt><dd><pre class=code><span class=library>table.concat</span>({<span class=string>"a"</span>, <span class=string>"b"</span>, <span class=string>"c"</span>}, <span class=string>","</span>) <span class=comment>--&gt; "a,b,c"</span>
</pre>
</dl>
<p>
Other interfaces are possible, largely dependent on the choice of split interface since join is often intended to be the inverse operation of split.
<p>
<hr><h2>Splitting Strings</h2>
<p>
First of all, although Lua does not have a split function in its standard library, it does have <code>string.gmatch</code><a href=http://www.lua.org/manual/5.2/manual.html#pdf-string.gmatch>[4]</a>, which can be used instead of a split function in many cases. Unlike a split function, <code>string.gmatch</code> takes a pattern to match the non-delimiter text, instead of the delimiters themselves:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>local</span> example = <span class=string>"an example string"</span>
<span class=keyword>for</span> i <span class=keyword>in</span> <span class=library>string.gmatch</span>(example, <span class=string>"%S+"</span>) <span class=keyword>do</span>
   <span class=library>print</span>(i)
<span class=keyword>end</span>

<span class=comment>-- output:</span>
<span class=comment>-- an</span>
<span class=comment>-- example</span>
<span class=comment>-- string</span>
</pre>
</dl>
<p>
A <code>split</code><a href=http://en.wikipedia.org/wiki/String_manipulation_algorithm#split>[1]</a> function
separates a string into a list of substrings,
breaking the original string on occurrences of some separator (character,
character set, or pattern). There are various ways to design a string split function. A summary of the design decisions is listed below.
<p>
Should split return a table array, a list, or an iterator?
<p>
<dl>
<dt><dd><pre class=code>split(<span class=string>"a,b,c"</span>, <span class=string>","</span>) <span class=comment>--&gt; {"a", "b", "c"}</span>
split(<span class=string>"a,b,c"</span>, <span class=string>","</span>) <span class=comment>--&gt; "a","b","c" (not scalable: Lua has a limit of a few thousand return values)</span>
<span class=keyword>for</span> x <span class=keyword>in</span> split(<span class=string>"a,b,c"</span>, <span class=string>","</span>) <span class=keyword>do</span> ..... <span class=keyword>end</span>
</pre>
</dl>
<p>
Should the separator be a string, Lua pattern, LPeg pattern, or regular expression?
<p>
<dl>
<dt><dd><pre class=code>split(<span class=string>"a  +b c"</span>, <span class=string>" +"</span>) <span class=comment>--&gt; {"a ", "b c"}</span>
split(<span class=string>"a  +b c"</span>, <span class=string>" +"</span>) <span class=comment>--&gt; {"a", "+b", "c"}</span>
split(<span class=string>"a  +b c"</span>, some_other_object) <span class=comment>--&gt; .....</span>
</pre>
</dl>
<p>
How should empty separators be handled?
<p>
<dl>
<dt><dd><pre class=code>split(<span class=string>"abc"</span>, <span class=string>""</span>) <span class=comment>--&gt; {"a", "b", "c"} </span>
split(<span class=string>"abc"</span>, <span class=string>""</span>) <span class=comment>--&gt; {"", "a", "b", "c", ""}</span>
split(<span class=string>"abc"</span>, <span class=string>""</span>) <span class=comment>--&gt; error</span>
split(<span class=string>"abc"</span>, <span class=string>"%d*"</span>) <span class=comment>--&gt; what about patterns that can evaluate to empty strings?</span>
</pre>
</dl>
<p>
<dl>
<dt><dd>Note: <code>split(s,"")</code> is a convenient idiom for splitting a string into characters. In Lua, we can alternately do <code>for c in s:gmatch"." do ..... end</code>.
</dl>
<p>
How should empty values be handled?
<p>
<dl>
<dt><dd><pre class=code>split(<span class=string>",,a,b,c,"</span>, <span class=string>","</span>) <span class=comment>--&gt; {"a", "b", "c"}</span>
split(<span class=string>",,a,b,c,"</span>, <span class=string>","</span>) <span class=comment>--&gt; {"", "", "a", "b", "c", ""}</span>
split(<span class=string>","</span>, <span class=string>","</span>) <span class=comment>--&gt; {} or {""} or {"", ""} ?</span>
split(<span class=string>""</span>, <span class=string>","</span>) <span class=comment>--&gt; {} or {""} ?</span>
</pre>
</dl>
<p>
<dl>
<dt><dd>Note: Although splitting and joining are roughly inverses, the operations are not necessarily uniquely determined, particularly when there are empty strings. <code>join({"",""}, "")</code>, <code>join({""}, "")</code> and <code>join({}, "")</code> all result in the same string <code>""</code>. Therefore, the choice of what the inverse operation <code>split("", "")</code> should return is not immediately clear.
</dl>
<p>
<dl>
<dt><dd>Note: completely ignoring empty values can be undesirable, such as for rows in a CSV file where column positions matter. A CSV file with empty rows "" is unclear: is this an column containing an empty value or are there zero columns? A zero column CSV file is unlikely though perhaps not impossible.
</dl>
<p>
Should there be an argument to limit the number of splits?
<p>
<dl>
<dt><dd><pre class=code>split(<span class=string>"a,b,c"</span>, <span class=string>","</span>, 2) <span class=comment>--&gt; {"a", "b,c"}</span>
</pre>
</dl>
<p>
Should the separator be returned? This is more useful when the separator is a pattern, in which case the separator can vary:
<p>
<dl>
<dt><dd><pre class=code>split(<span class=string>"a  b c"</span>, <span class=string>" +"</span>) <span class=comment>--&gt; {"a", "  ", "b", " ", "c"}</span>
</pre>
</dl>
<p>
<dl>
<dt><dd>Note: Note also that <code>string.gmatch</code> <a href=http://www.lua.org/manual/5.1/manual.html#pdf-string.gmatch>[5]</a> is in a way a dual of <code>split</code>, returning the substrings that match a pattern and discarding strings between them rather than the other way around. A function that returns both is sometimes called <code>partition</code> <a href=http://en.wikipedia.org/wiki/Comparison_of_programming_languages_%28string_functions%29#partition>[6]</a>.
</dl>
<p>
<hr><h3>Method: Split by pattern using <code>string.gsub</code>/<code>string.match</code></h3>
<p>
Break a string up at occurrences of a single character. If the number of
fields is known:
<p>
<dl>
<dt><dd><pre class=code>str:match( (<span class=string>"([^"</span>..sep..<span class=string>"]*)"</span>..sep):rep(nsep) )
</pre>
</dl>
<p>
If the number of fields is not known
<p>
<dl>
<dt><dd><pre class=code>fields = {str:match((str:gsub(<span class=string>"[^"</span>..sep..<span class=string>"]*"</span>..sep, <span class=string>"([^"</span>..sep..<span class=string>"]*)"</span>..sep)))}
</pre>
</dl>
<p>
Some might call the above a hack :) <code>sep</code> will need to be escaped if it is a
pattern metacharacter, and you'd probably be better off precomputing and/or
memorizing the patterns. And it leaves off values after the last separator. E.g. "a,b,c" returns "a" and "b" but not "c"
<p>
<hr><h3>Method: Using only <code>string.gsub</code></h3>
<p>
<dl>
<dt><dd><pre class=code>fields = {}
str:gsub(<span class=string>"([^"</span>..sep..<span class=string>"]*)"</span>..sep, <span class=keyword>function</span>(c)
   <span class=library>table.insert</span>(fields, c)
<span class=keyword>end</span>)
</pre>
</dl>
<p>
<strong>Does not work as expected:</strong>
<dl>
<dt><dd><pre class=code>str, sep = <span class=string>"1:2:3"</span>, <span class=string>":"</span>
fields = {}
str:gsub(<span class=string>"([^"</span>..sep..<span class=string>"]*)"</span>..sep, <span class=keyword>function</span>(c)
   <span class=library>table.insert</span>(fields, c)
<span class=keyword>end</span>)
<span class=keyword>for</span> i,v <span class=keyword>in</span> <span class=library>ipairs</span>(fields) <span class=keyword>do</span>
   <span class=library>print</span>(i,v)
<span class=keyword>end</span>

<span class=comment>-- output:</span>
<span class=comment>-- 1        1</span>
<span class=comment>-- 2        2</span>
</pre>
</dl>
<p>
<strong>Fix:</strong>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> <span class=library>string</span>:split(sep)
   <span class=keyword>local</span> sep, fields = sep <span class=keyword>or</span> <span class=string>":"</span>, {}
   <span class=keyword>local</span> pattern = <span class=library>string.format</span>(<span class=string>"([^%s]+)"</span>, sep)
   self:gsub(pattern, <span class=keyword>function</span>(c) fields[#fields+1] = c <span class=keyword>end</span>)
   <span class=keyword>return</span> fields
<span class=keyword>end</span>
</pre>
</dl>
<p>
<p>
<strong>Example:</strong> split a string into words, or return nil
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> justWords(str)
   <span class=keyword>local</span> t = {}
   <span class=keyword>local</span> <span class=keyword>function</span> helper(word)
      <span class=library>table.insert</span>(t, word)
      <span class=keyword>return</span> <span class=string>""</span>
   <span class=keyword>end</span>
   <span class=keyword>if</span> <span class=keyword>not</span> str:gsub(<span class=string>"%w+"</span>, helper):find<span class=string>"%S"</span> <span class=keyword>then</span>
      <span class=keyword>return</span> t
   <span class=keyword>end</span>
<span class=keyword>end</span>
</pre>
</dl>
<p>
<hr><h3>Method: Split a string with a pattern, Take One</h3>
<p>
This splits a string using the pattern <code>sep</code>. It calls <code>func</code> for each
segment. When <code>func</code> is called, the first argument is the segment and the
remaining arguments are the captures from <code>sep</code>, if any. On the last
segment, <code>func</code> will be called with just one argument. (This could be used
as a flag, or you could use two different functions). <code>sep</code> must not match
the empty string. Enhancements are left as an exercise :)
<p>
<dl>
<dt><dd><pre class=code>func((str:gsub(<span class=string>"(.-)("</span>..sep..<span class=string>")"</span>, func)))
</pre>
</dl>
<p>
<strong>Example:</strong> Split a string into lines separated by either DOS or Unix line
endings, creating a table out of the results.
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> lines(str)
   <span class=keyword>local</span> t = {}
   <span class=keyword>local</span> <span class=keyword>function</span> helper(line)
      <span class=library>table.insert</span>(t, line)
      <span class=keyword>return</span> <span class=string>""</span>
   <span class=keyword>end</span>
   helper((str:gsub(<span class=string>"(.-)\r?\n"</span>, helper)))
   <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
<hr><h3>Function: Split a string with a pattern, Take Two</h3>
<p>
The problem with using gsub as above is that it can't handle the case when the
separator pattern doesn't appear at the end of the string. In that case the
final "(.-)" never gets to capture the end of the string, because the overall
pattern fails to match. To handle that case you have to do something a little
more complicated. The split function below behaves more or less like split in
perl or python. In particular, single matches at the beginning and end of the
string do not create new elements. Multiple matches in a row create empty
string elements.
<p>
<dl>
<dt><dd><pre class=code><span class=comment>-- Compatibility: Lua-5.1</span>
<span class=keyword>function</span> split(str, pat)
   <span class=keyword>local</span> t = {}  <span class=comment>-- NOTE: use {n = 0} in Lua-5.0</span>
   <span class=keyword>local</span> fpat = <span class=string>"(.-)"</span> .. pat
   <span class=keyword>local</span> last_end = 1
   <span class=keyword>local</span> s, e, cap = str:find(fpat, 1)
   <span class=keyword>while</span> s <span class=keyword>do</span>
      <span class=keyword>if</span> s ~= 1 <span class=keyword>or</span> cap ~= <span class=string>""</span> <span class=keyword>then</span>
         <span class=library>table.insert</span>(t, cap)
      <span class=keyword>end</span>
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   <span class=keyword>end</span>
   <span class=keyword>if</span> last_end &lt;= #str <span class=keyword>then</span>
      cap = str:sub(last_end)
      <span class=library>table.insert</span>(t, cap)
   <span class=keyword>end</span>
   <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
<strong>Example:</strong> Split a file path string into components.
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> split_path(str)
   <span class=keyword>return</span> split(str,<span class=string>'[\\/]+'</span>)
<span class=keyword>end</span>

parts = split_path(<span class=string>"/usr/local/bin"</span>)
  <span class=comment>--&gt; {'usr','local','bin'}</span>
</pre>
</dl>
<p>
<strong>Test Cases:</strong>
<dl>
<dt><dd><pre class=code>split(<span class=string>'foo/bar/baz/test'</span>,<span class=string>'/'</span>)
  <span class=comment>--&gt; {'foo','bar','baz','test'}</span>
split(<span class=string>'/foo/bar/baz/test'</span>,<span class=string>'/'</span>)
  <span class=comment>--&gt; {'foo','bar','baz','test'}</span>
split(<span class=string>'/foo/bar/baz/test/'</span>,<span class=string>'/'</span>)
  <span class=comment>--&gt; {'foo','bar','baz','test'}</span>
split(<span class=string>'/foo/bar//baz/test///'</span>,<span class=string>'/'</span>)
  <span class=comment>--&gt; {'foo','bar','','baz','test','',''}</span>
split(<span class=string>'//foo////bar/baz///test///'</span>,<span class=string>'/+'</span>)
  <span class=comment>--&gt; {'foo','bar','baz','test'}</span>
split(<span class=string>'foo'</span>,<span class=string>'/+'</span>)
  <span class=comment>--&gt; {'foo'}</span>
split(<span class=string>''</span>,<span class=string>'/+'</span>)
  <span class=comment>--&gt; {}</span>
split(<span class=string>'foo'</span>,<span class=string>''</span>)  <span class=comment>-- opps! infinite loop!</span>
</pre>
</dl>
<p>
<hr><h3>Function: Split a string with a pattern, Take Three</h3>
<p>
After a discussion on this topic in the mailing list, I made my own function...
I took, unknowingly, a way similar to the function above, except I use gfind
to iterate, and I see the single matches at beginning and end of string as
empty fields. As above, multiple successive delimiters create empty string
elements.
<p>
<dl>
<dt><dd><pre class=code><span class=comment>-- Compatibility: Lua-5.0</span>
<span class=keyword>function</span> Split(str, delim, maxNb)
   <span class=comment>-- Eliminate bad cases...</span>
   <span class=keyword>if</span> <span class=library>string.find</span>(str, delim) == <span class=keyword>nil</span> <span class=keyword>then</span>
      <span class=keyword>return</span> { str }
   <span class=keyword>end</span>
   <span class=keyword>if</span> maxNb == <span class=keyword>nil</span> <span class=keyword>or</span> maxNb &lt; 1 <span class=keyword>then</span>
      maxNb = 0    <span class=comment>-- No limit</span>
   <span class=keyword>end</span>
   <span class=keyword>local</span> result = {}
   <span class=keyword>local</span> pat = <span class=string>"(.-)"</span> .. delim .. <span class=string>"()"</span>
   <span class=keyword>local</span> nb = 0
   <span class=keyword>local</span> lastPos
   <span class=keyword>for</span> part, pos <span class=keyword>in</span> <span class=library>string.gfind</span>(str, pat) <span class=keyword>do</span>
      nb = nb + 1
      result[nb] = part
      lastPos = pos
      <span class=keyword>if</span> nb == maxNb <span class=keyword>then</span>
         <span class=keyword>break</span>
      <span class=keyword>end</span>
   <span class=keyword>end</span>
   <span class=comment>-- Handle the last field</span>
   <span class=keyword>if</span> nb ~= maxNb <span class=keyword>then</span>
      result[nb + 1] = <span class=library>string.sub</span>(str, lastPos)
   <span class=keyword>end</span>
   <span class=keyword>return</span> result
<span class=keyword>end</span>
</pre>
</dl>
<p>
<strong>Test Cases:</strong>
<p>
<dl>
<dt><dd><pre class=code>ShowSplit(<span class=string>"abc"</span>, <span class=string>''</span>)
<span class=comment>--&gt; { [1] = "", [2] = "", [3] = "", [4] = "", [5] = "" }</span>
<span class=comment>-- No infite loop... but garbage in, garbage out...</span>
ShowSplit(<span class=string>""</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "" }</span>
ShowSplit(<span class=string>"abc"</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "abc" }</span>
ShowSplit(<span class=string>"a,b,c"</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "a", [2] = "b", [3] = "c" }</span>
ShowSplit(<span class=string>"a,b,c,"</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "a", [2] = "b", [3] = "c", [4] = "" }</span>
ShowSplit(<span class=string>",a,b,c,"</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "", [2] = "a", [3] = "b", [4] = "c", [5] = "" }</span>
ShowSplit(<span class=string>"x,,,y"</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "x", [2] = "", [3] = "", [4] = "y" }</span>
ShowSplit(<span class=string>",,,"</span>, <span class=string>','</span>)
<span class=comment>--&gt; { [1] = "", [2] = "", [3] = "", [4] = "" }</span>
ShowSplit(<span class=string>"x!yy!zzz!@"</span>, <span class=string>'!'</span>, 4)
<span class=comment>--&gt; { [1] = "x", [2] = "yy", [3] = "zzz", [4] = "@" }</span>
ShowSplit(<span class=string>"x!yy!zzz!@"</span>, <span class=string>'!'</span>, 3)
<span class=comment>--&gt; { [1] = "x", [2] = "yy", [3] = "zzz" }</span>
ShowSplit(<span class=string>"x!yy!zzz!@"</span>, <span class=string>'!'</span>, 1)
<span class=comment>--&gt; { [1] = "x" }</span>

ShowSplit(<span class=string>"a:b:i:p:u:random:garbage"</span>, <span class=string>":"</span>, 5)
<span class=comment>--&gt; { [1] = "a", [2] = "b", [3] = "i", [4] = "p", [5] = "u" }</span>
ShowSplit(<span class=string>"hr , br ;  p ,span, div"</span>, <span class=string>'%s*[;,]%s*'</span>)
<span class=comment>--&gt; { [1] = "hr", [2] = "br", [3] = "p", [4] = "span", [5] = "div" }</span>
</pre>
</dl>
<p>
(<a href=http://lua-users.org/wiki/PhilippeLhoste>PhilippeLhoste</a>)
<p>
<hr><h3>Function: Perl-like split/join</h3>
<p>
Many people miss Perl-like split/join functions in Lua. Here are mine:
<p>
<dl>
<dt><dd><pre class=code><span class=comment>-- Concat the contents of the parameter list,</span>
<span class=comment>-- separated by the string delimiter (just like in perl)</span>
<span class=comment>-- example: strjoin(", ", {"Anna", "Bob", "Charlie", "Dolores"})</span>
<span class=keyword>function</span> strjoin(delimiter, list)
   <span class=keyword>local</span> len = getn(list)
   <span class=keyword>if</span> len == 0 <span class=keyword>then</span>
      <span class=keyword>return</span> <span class=string>""</span>
   <span class=keyword>end</span>
   <span class=keyword>local</span> <span class=library>string</span> = list[1]
   <span class=keyword>for</span> i = 2, len <span class=keyword>do</span>
      <span class=library>string</span> = <span class=library>string</span> .. delimiter .. list[i]
   <span class=keyword>end</span>
   <span class=keyword>return</span> <span class=library>string</span>
<span class=keyword>end</span>

<span class=comment>-- Split text into a list consisting of the strings in text,</span>
<span class=comment>-- separated by strings matching delimiter (which may be a pattern). </span>
<span class=comment>-- example: strsplit(",%s*", "Anna, Bob, Charlie,Dolores")</span>
<span class=keyword>function</span> strsplit(delimiter, text)
   <span class=keyword>local</span> list = {}
   <span class=keyword>local</span> pos = 1
   <span class=keyword>if</span> strfind(<span class=string>""</span>, delimiter, 1) <span class=keyword>then</span> <span class=comment>-- this would result in endless loops</span>
      <span class=library>error</span>(<span class=string>"delimiter matches empty string!"</span>)
   <span class=keyword>end</span>
   <span class=keyword>while</span> 1 <span class=keyword>do</span>
      <span class=keyword>local</span> first, last = strfind(text, delimiter, pos)
      <span class=keyword>if</span> first <span class=keyword>then</span> <span class=comment>-- found?</span>
         tinsert(list, strsub(text, pos, first-1))
         pos = last+1
      <span class=keyword>else</span>
         tinsert(list, strsub(text, pos))
         <span class=keyword>break</span>
      <span class=keyword>end</span>
   <span class=keyword>end</span>
   <span class=keyword>return</span> list
<span class=keyword>end</span>
</pre>
</dl>
<p>
(<a href=http://lua-users.org/wiki/PeterPrade>PeterPrade</a>)
<p>
<hr><h3>Function: Perl-like split/join, alternative</h3>
<p>
Here's my own split function, for comparison. It's largely the same as the
above; not quite as DRY but (IMO) slightly cleaner. It doesn't use gfind (as
suggested below) because I wanted to be able to specify a pattern for the
split string, not a pattern for the data sections. If speed is paramount, it
might be made faster by caching string.find as a local 'strfind' variable, as
the above does.
<p>
<dl>
<dt><dd><pre class=code><span class=comment>--Written for 5.0; could be made slightly cleaner with 5.1</span>
<span class=comment>--Splits a string based on a separator string or pattern;</span>
<span class=comment>--returns an array of pieces of the string.</span>
<span class=comment>--(May optionally supply a table as the third parameter which will be filled </span>
with the results.)
<span class=keyword>function</span> <span class=library>string</span>:split( inSplitPattern, outResults )
   <span class=keyword>if</span> <span class=keyword>not</span> outResults <span class=keyword>then</span>
      outResults = { }
   <span class=keyword>end</span>
   <span class=keyword>local</span> theStart = 1
   <span class=keyword>local</span> theSplitStart, theSplitEnd = <span class=library>string.find</span>( self, inSplitPattern,
theStart )
   <span class=keyword>while</span> theSplitStart <span class=keyword>do</span>
      <span class=library>table.insert</span>( outResults, <span class=library>string.sub</span>( self, theStart, theSplitStart-1 ) )
      theStart = theSplitEnd + 1
      theSplitStart, theSplitEnd = <span class=library>string.find</span>( self, inSplitPattern, theStart )
   <span class=keyword>end</span>
   <span class=library>table.insert</span>( outResults, <span class=library>string.sub</span>( self, theStart ) )
   <span class=keyword>return</span> outResults
<span class=keyword>end</span>
</pre>
</dl>
<p>
(<a href=http://lua-users.org/wiki/GavinKistner>GavinKistner</a>)
<p>
<hr><h3>Function: PHP-like explode</h3>
<p>
Explode string into table with seperator (moved from Table<code></code>Utils):
<p>
<dl>
<dt><dd><pre class=code><span class=comment>-- explode(seperator, string)</span>
<span class=keyword>function</span> explode(d,p)
   <span class=keyword>local</span> t, ll
   t={}
   ll=0
   <span class=keyword>if</span>(#p == 1) <span class=keyword>then</span>
      <span class=keyword>return</span> {p}
   <span class=keyword>end</span>
   <span class=keyword>while</span> <span class=keyword>true</span> <span class=keyword>do</span>
      l = <span class=library>string.find</span>(p, d, ll, <span class=keyword>true</span>) <span class=comment>-- find the next d in the string</span>
      <span class=keyword>if</span> l ~= <span class=keyword>nil</span> <span class=keyword>then</span> <span class=comment>-- if "not not" found then..</span>
         <span class=library>table.insert</span>(t, <span class=library>string.sub</span>(p,ll,l-1)) <span class=comment>-- Save it in our array.</span>
         ll = l + 1 <span class=comment>-- save just after where we found it for searching next time.</span>
      <span class=keyword>else</span>
         <span class=library>table.insert</span>(t, <span class=library>string.sub</span>(p,ll)) <span class=comment>-- Save what's left in our array.</span>
         <span class=keyword>break</span> <span class=comment>-- Break at end, as it should be, according to the lua manual.</span>
      <span class=keyword>end</span>
   <span class=keyword>end</span>
   <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
Here's my version of PHP style explode, supporting limit
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> explode(sep, str, limit)
   <span class=keyword>if</span> <span class=keyword>not</span> sep <span class=keyword>or</span> sep == <span class=string>""</span> <span class=keyword>then</span>
      <span class=keyword>return</span> <span class=keyword>false</span>
   <span class=keyword>end</span>
   <span class=keyword>if</span> <span class=keyword>not</span> str <span class=keyword>then</span>
      <span class=keyword>return</span> <span class=keyword>false</span>
   <span class=keyword>end</span>
   limit = limit <span class=keyword>or</span> mhuge
   <span class=keyword>if</span> limit == 0 <span class=keyword>or</span> limit == 1 <span class=keyword>then</span>
      <span class=keyword>return</span> {str}, 1
   <span class=keyword>end</span>

   <span class=keyword>local</span> r = {}
   <span class=keyword>local</span> n, init = 0, 1

   <span class=keyword>while</span> <span class=keyword>true</span> <span class=keyword>do</span>
      <span class=keyword>local</span> s,e = strfind(str, sep, init, <span class=keyword>true</span>)
      <span class=keyword>if</span> <span class=keyword>not</span> s <span class=keyword>then</span>
         <span class=keyword>break</span>
      <span class=keyword>end</span>
      r[#r+1] = strsub(str, init, s - 1)
      init = e + 1
      n = n + 1
      <span class=keyword>if</span> n == limit - 1 <span class=keyword>then</span>
         <span class=keyword>break</span>
      <span class=keyword>end</span>
   <span class=keyword>end</span>

   <span class=keyword>if</span> init &lt;= strlen(str) <span class=keyword>then</span>
      r[#r+1] = strsub(str, init)
   <span class=keyword>else</span>
      r[#r+1] = <span class=string>""</span>
   <span class=keyword>end</span>
   n = n + 1

   <span class=keyword>if</span> limit &lt; 0 <span class=keyword>then</span>
      <span class=keyword>for</span> i=n, n + limit + 1, -1 <span class=keyword>do</span> r[i] = <span class=keyword>nil</span> <span class=keyword>end</span>
      n = n + limit
   <span class=keyword>end</span>

   <span class=keyword>return</span> r, n
<span class=keyword>end</span>
</pre>
</dl>
(Lance Li)
<p>
<hr><h3>Function: Using metatable and __index</h3>
<p>
This function uses a metatable's __index function to populate the table of
split parts. This function does not try to (correctly) invert the pattern, and
so really doesn't work as most string split functions do.
<p>
<dl>
<dt><dd><pre class=code><span class=comment>--[[ written for Lua 5.1
split a string by a pattern, take care to create the "inverse" pattern
yourself. default pattern splits by white space.
]]</span>
<span class=library>string.split</span> = <span class=keyword>function</span>(str, pattern)
   pattern = pattern <span class=keyword>or</span> <span class=string>"[^%s]+"</span>
   <span class=keyword>if</span> pattern:len() == 0 <span class=keyword>then</span>
      pattern = <span class=string>"[^%s]+"</span>
   <span class=keyword>end</span>
   <span class=keyword>local</span> parts = {__index = <span class=library>table.insert</span>}
   <span class=library>setmetatable</span>(parts, parts)
   str:gsub(pattern, parts)
   <span class=library>setmetatable</span>(parts, <span class=keyword>nil</span>)
   parts.__index = <span class=keyword>nil</span>
   <span class=keyword>return</span> parts
<span class=keyword>end</span>
<span class=comment>-- example 1</span>
str = <span class=string>"no separators in this string"</span>
parts = str:split( <span class=string>"[^,]+"</span> )
<span class=library>print</span>( # parts )
<span class=library>table.foreach</span>(parts, <span class=library>print</span>)
<span class=comment>--[[ output:
1
1	no separators in this string
]]</span>

<span class=comment>-- example 2</span>
str = <span class=string>"   split, comma, separated  , , string   "</span>
parts = str:split( <span class=string>"[^,%s]+"</span> )
<span class=library>print</span>( # parts )
<span class=library>table.foreach</span>(parts, <span class=library>print</span>)
<span class=comment>--[[ output:
4
1	split
2	comma
3	separated
4	string
]]</span>
</pre>
</dl>
<p>
<hr><h3>Function: true Python semantics for split</h3>
<p>
This is the Python behavior:
<p>
<dl>
<dt><dd><pre>Python 2.5.1 (r251:54863, Jun 15 2008, 18:24:51)
[GCC 4.3.0 20080428 (Red Hat 4.3.0-8)] on linux2
&gt;&gt;&gt; 'x!yy!zzz!@'.split('!')
['x', 'yy', 'zzz', '@']
&gt;&gt;&gt; 'x!yy!zzz!@'.split('!', 3)
['x', 'yy', 'zzz', '@']
&gt;&gt;&gt; 'x!yy!zzz!@'.split('!', 2)
['x', 'yy', 'zzz!@']
&gt;&gt;&gt; 'x!yy!zzz!@'.split('!', 1)
['x', 'yy!zzz!@']
</pre>
</dl>
<p>
And IMHO this Lua function implements this semantics:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> <span class=library>string</span>:split(sSeparator, nMax, bRegexp)
   <span class=library>assert</span>(sSeparator ~= <span class=string>''</span>)
   <span class=library>assert</span>(nMax == <span class=keyword>nil</span> <span class=keyword>or</span> nMax &gt;= 1)

   <span class=keyword>local</span> aRecord = {}

   <span class=keyword>if</span> self:len() &gt; 0 <span class=keyword>then</span>
      <span class=keyword>local</span> bPlain = <span class=keyword>not</span> bRegexp
      nMax = nMax <span class=keyword>or</span> -1

      <span class=keyword>local</span> nField, nStart = 1, 1
      <span class=keyword>local</span> nFirst,nLast = self:find(sSeparator, nStart, bPlain)
      <span class=keyword>while</span> nFirst <span class=keyword>and</span> nMax ~= 0 <span class=keyword>do</span>
         aRecord[nField] = self:sub(nStart, nFirst-1)
         nField = nField+1
         nStart = nLast+1
         nFirst,nLast = self:find(sSeparator, nStart, bPlain)
         nMax = nMax-1
      <span class=keyword>end</span>
      aRecord[nField] = self:sub(nStart)
   <span class=keyword>end</span>

   <span class=keyword>return</span> aRecord
<span class=keyword>end</span>
</pre>

</dl>
<p>
Observe the possibility to use simple strings or regular expressions as delimiters.
<p>
<strong>Test Cases:</strong>
<p>
<dl>
<dt><dd><pre class=code>Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
...
&gt; <span class=keyword>for</span> k,v <span class=keyword>in</span> <span class=library>next</span>, <span class=library>string.split</span>(<span class=string>'x!yy!zzz!@'</span>, <span class=string>'!'</span>) <span class=keyword>do</span> <span class=library>print</span>(v) <span class=keyword>end</span>
x
yy
zzz
@
&gt; <span class=keyword>for</span> k,v <span class=keyword>in</span> <span class=library>next</span>, <span class=library>string.split</span>(<span class=string>'x!yy!zzz!@'</span>, <span class=string>'!'</span>, 3) <span class=keyword>do</span> <span class=library>print</span>(v) <span class=keyword>end</span>
x
yy
zzz
@
&gt; <span class=keyword>for</span> k,v <span class=keyword>in</span> <span class=library>next</span>, <span class=library>string.split</span>(<span class=string>'x!yy!zzz!@'</span>, <span class=string>'!'</span>, 2) <span class=keyword>do</span> <span class=library>print</span>(v) <span class=keyword>end</span>
x
yy
zzz!@
&gt; <span class=keyword>for</span> k,v <span class=keyword>in</span> <span class=library>next</span>, <span class=library>string.split</span>(<span class=string>'x!yy!zzz!@'</span>, <span class=string>'!'</span>, 1) <span class=keyword>do</span> <span class=library>print</span>(v) <span class=keyword>end</span>
x
yy!zzz!@
</pre>
</dl>
<p>
(<a href=http://lua-users.org/wiki/JoanOrdinas>JoanOrdinas</a>)
<p>
<hr><h3>Using Coroutines</h3>
If we define split simply as "return all 0-n character occurences followed by a separator, plus what's left of the string", which I think results in the most intuitive splitting logic, then we get a simple implementation using just gmatch which covers all cases and still allows the separator to be a pattern:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> gsplit(s,sep)
   <span class=keyword>return</span> <span class=library>coroutine.wrap</span>(<span class=keyword>function</span>()
      <span class=keyword>if</span> s == <span class=string>''</span> <span class=keyword>or</span> sep == <span class=string>''</span> <span class=keyword>then</span>
         <span class=library>coroutine.yield</span>(s)
         <span class=keyword>return</span>
      <span class=keyword>end</span>
      <span class=keyword>local</span> lasti = 1
      <span class=keyword>for</span> v,i <span class=keyword>in</span> s:gmatch(<span class=string>'(.-)'</span>..sep..<span class=string>'()'</span>) <span class=keyword>do</span>
         <span class=library>coroutine.yield</span>(v)
         lasti = i
      <span class=keyword>end</span>
      <span class=library>coroutine.yield</span>(s:sub(lasti))
   <span class=keyword>end</span>)
<span class=keyword>end</span>

<span class=comment>-- same idea without coroutines</span>
<span class=keyword>function</span> gsplit2(s,sep)
   <span class=keyword>local</span> lasti, done, g = 1, <span class=keyword>false</span>, s:gmatch(<span class=string>'(.-)'</span>..sep..<span class=string>'()'</span>)
   <span class=keyword>return</span> <span class=keyword>function</span>()
      <span class=keyword>if</span> done <span class=keyword>then</span>
         <span class=keyword>return</span>
      <span class=keyword>end</span>
      <span class=keyword>local</span> v,i = g()
      <span class=keyword>if</span> s == <span class=string>''</span> <span class=keyword>or</span> sep == <span class=string>''</span> <span class=keyword>then</span>
         done = <span class=keyword>true</span>
         <span class=keyword>return</span> s
      <span class=keyword>end</span>
      <span class=keyword>if</span> v == <span class=keyword>nil</span> <span class=keyword>then</span>
         done = <span class=keyword>true</span>
         <span class=keyword>return</span> s:sub(lasti)
      <span class=keyword>end</span>
      lasti = i
      <span class=keyword>return</span> v
   <span class=keyword>end</span>
<span class=keyword>end</span>

The {{gsplit()}} above returns an iterator, so other API variants can be easily derived from it:

        {{{!Lua
<span class=keyword>function</span> iunpack(i,s,v1)
   <span class=keyword>local</span> <span class=keyword>function</span> pass(...)
      <span class=keyword>local</span> v1 = i(s,v1)
      <span class=keyword>if</span> v1 == <span class=keyword>nil</span> <span class=keyword>then</span>
         <span class=keyword>return</span> ...
      <span class=keyword>end</span>
      <span class=keyword>return</span> v1, pass(...)
   <span class=keyword>end</span>
   <span class=keyword>return</span> pass()
<span class=keyword>end</span>

<span class=keyword>function</span> split(s,sep)
   <span class=keyword>return</span> iunpack(gsplit(s,sep))
<span class=keyword>end</span>

<span class=keyword>function</span> accumulate(t,i,s,v)
   <span class=keyword>for</span> v <span class=keyword>in</span> i,s,v <span class=keyword>do</span>
      t[#t+1] = v
   <span class=keyword>end</span>
   <span class=keyword>return</span> t
<span class=keyword>end</span>

<span class=keyword>function</span> tsplit(s,sep)
   <span class=keyword>return</span> accumulate({}, gsplit(s,sep))
<span class=keyword>end</span>
</pre>
</dl>
<p>
Note that the above implementation does not allow captures in the separator. To allow for that, another closure must be created to pass along the additional captured strings (see <a href=http://lua-users.org/wiki/VarargTheSecondClassCitizen>VarargTheSecondClassCitizen</a>). The semantics also get muddy (I suppose one use case would be wanting to know what the actual separator was for each string, eg. for a separator pattern like [%.,;]).
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> gsplit(s,sep)
   <span class=keyword>local</span> i, done, g = 1, <span class=keyword>false</span>, s:gmatch(<span class=string>'(.-)'</span>..sep..<span class=string>'()'</span>)
   <span class=keyword>local</span> <span class=keyword>function</span> pass(...)
      <span class=keyword>if</span> ... == <span class=keyword>nil</span> <span class=keyword>then</span>
         done = <span class=keyword>true</span>
         <span class=keyword>return</span> s:sub(i)
      <span class=keyword>end</span>
      i = <span class=library>select</span>(<span class=library>select</span>(<span class=string>'#'</span>,...),...)
      <span class=keyword>return</span> ...
   <span class=keyword>end</span>
   <span class=keyword>return</span> <span class=keyword>function</span>()
      <span class=keyword>if</span> done <span class=keyword>then</span>
         <span class=keyword>return</span>
      <span class=keyword>end</span>
      <span class=keyword>if</span> s == <span class=string>''</span> <span class=keyword>or</span> sep == <span class=string>''</span> <span class=keyword>then</span>
         done = <span class=keyword>true</span>
         <span class=keyword>return</span> s
      <span class=keyword>end</span>
      <span class=keyword>return</span> pass(g())
   <span class=keyword>end</span>
<span class=keyword>end</span>
</pre>
</dl>
<p>
The problem with the above implementation is that however easy to read, the (.-) pattern in Lua has awful performance, hence the following implementation based on only string.find (allows for captures in the separator and adds a third argument "plain", similar to string.find):
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> <span class=library>string.gsplit</span>(s, sep, plain)
   <span class=keyword>local</span> start = 1
   <span class=keyword>local</span> done = <span class=keyword>false</span>
   <span class=keyword>local</span> <span class=keyword>function</span> pass(i, j, ...)
      <span class=keyword>if</span> i <span class=keyword>then</span>
         <span class=keyword>local</span> seg = s:sub(start, i - 1)
         start = j + 1
         <span class=keyword>return</span> seg, ...
      <span class=keyword>else</span>
         done = <span class=keyword>true</span>
         <span class=keyword>return</span> s:sub(start)
      <span class=keyword>end</span>
   <span class=keyword>end</span>
   <span class=keyword>return</span> <span class=keyword>function</span>()
      <span class=keyword>if</span> done <span class=keyword>then</span>
         <span class=keyword>return</span>
       <span class=keyword>end</span>
      <span class=keyword>if</span> sep == <span class=string>''</span> <span class=keyword>then</span>
         done = <span class=keyword>true</span>
         <span class=keyword>return</span> s
      <span class=keyword>end</span>
      <span class=keyword>return</span> pass(s:find(sep, start, plain))
   <span class=keyword>end</span>
<span class=keyword>end</span>
</pre>
</dl>
<p>
Unit testing:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>local</span> <span class=keyword>function</span> test(s,sep,expect)
   <span class=keyword>local</span> t={} <span class=keyword>for</span> c <span class=keyword>in</span> s:gsplit(sep) <span class=keyword>do</span> <span class=library>table.insert</span>(t,c) <span class=keyword>end</span>
   <span class=library>assert</span>(#t == #expect)
   <span class=keyword>for</span> i=1,#t <span class=keyword>do</span> <span class=library>assert</span>(t[i] == expect[i]) <span class=keyword>end</span>
   test(t, expect)
<span class=keyword>end</span>
test(<span class=string>''</span>,<span class=string>''</span>,{<span class=string>''</span>})
test(<span class=string>''</span>,<span class=string>'asdf'</span>,{<span class=string>''</span>})
test(<span class=string>'asdf'</span>,<span class=string>''</span>,{<span class=string>'asdf'</span>})
test(<span class=string>''</span>, <span class=string>','</span>, {<span class=string>''</span>})
test(<span class=string>','</span>, <span class=string>','</span>, {<span class=string>''</span>,<span class=string>''</span>})
test(<span class=string>'a'</span>, <span class=string>','</span>, {<span class=string>'a'</span>})
test(<span class=string>'a,b'</span>, <span class=string>','</span>, {<span class=string>'a'</span>,<span class=string>'b'</span>})
test(<span class=string>'a,b,'</span>, <span class=string>','</span>, {<span class=string>'a'</span>,<span class=string>'b'</span>,<span class=string>''</span>})
test(<span class=string>',a,b'</span>, <span class=string>','</span>, {<span class=string>''</span>,<span class=string>'a'</span>,<span class=string>'b'</span>})
test(<span class=string>',a,b,'</span>, <span class=string>','</span>, {<span class=string>''</span>,<span class=string>'a'</span>,<span class=string>'b'</span>,<span class=string>''</span>})
test(<span class=string>',a,,b,'</span>, <span class=string>','</span>, {<span class=string>''</span>,<span class=string>'a'</span>,<span class=string>''</span>,<span class=string>'b'</span>,<span class=string>''</span>})
test(<span class=string>'a,,b'</span>, <span class=string>','</span>, {<span class=string>'a'</span>,<span class=string>''</span>,<span class=string>'b'</span>})
test(<span class=string>'asd  ,   fgh  ,;  qwe, rty.   ,jkl'</span>, <span class=string>'%s*[,.;]%s*'</span>, {<span class=string>'asd'</span>,<span class=string>'fgh'</span>,<span class=string>''</span>,<span class=string>'qwe'</span>,<span class=string>'rty'</span>,<span class=string>''</span>,<span class=string>'jkl'</span>})
test(<span class=string>'Spam eggs spam spam and ham'</span>, <span class=string>'spam'</span>, {<span class=string>'Spam eggs '</span>,<span class=string>' '</span>,<span class=string>' and ham'</span>})
</pre>
</dl>
<p>
(<a href=http://lua-users.org/wiki/CosminApreutesei>CosminApreutesei</a>)
<p>
<hr><dl>
<dt><dd><pre class=code><span class=comment>-- single char string splitter, sep *must* be a single char pattern</span>
<span class=comment>-- *probably* escaped with % if it has any special pattern meaning, eg "%." not "."</span>
<span class=comment>-- so good for splitting paths on "/" or "%." which is a common need</span>
<span class=keyword>local</span> <span class=keyword>function</span> csplit(str,sep)
   <span class=keyword>local</span> ret={}
   <span class=keyword>local</span> n=1
   <span class=keyword>for</span> w <span class=keyword>in</span> str:gmatch(<span class=string>"([^"</span>..sep..<span class=string>"]*)"</span>) <span class=keyword>do</span>
      ret[n] = ret[n] <span class=keyword>or</span> w <span class=comment>-- only set once (so the blank after a string is ignored)</span>
      <span class=keyword>if</span> w==<span class=string>""</span> <span class=keyword>then</span>
         n = n + 1
      <span class=keyword>end</span> <span class=comment>-- step forwards on a blank but not a string</span>
   <span class=keyword>end</span>
   <span class=keyword>return</span> ret
<span class=keyword>end</span>

<span class=comment>-- the following is true of any string, csplit will do the reverse of a concat</span>
<span class=keyword>local</span> str=<span class=string>""</span>
<span class=library>print</span>(str , <span class=library>assert</span>( <span class=library>table.concat</span>( csplit(str,<span class=string>"/"</span>) , <span class=string>"/"</span> ) == str ) )

<span class=keyword>local</span> str=<span class=string>"only"</span>
<span class=library>print</span>(str , <span class=library>assert</span>( <span class=library>table.concat</span>( csplit(str,<span class=string>"/"</span>) , <span class=string>"/"</span> ) == str ) )

<span class=keyword>local</span> str=<span class=string>"/test//ok/"</span>
<span class=library>print</span>(str , <span class=library>assert</span>( <span class=library>table.concat</span>( csplit(str,<span class=string>"/"</span>) , <span class=string>"/"</span> ) == str ) )

<span class=keyword>local</span> str=<span class=string>".test..ok."</span>
<span class=library>print</span>(str , <span class=library>assert</span>( <span class=library>table.concat</span>( csplit(str,<span class=string>"%."</span>) , <span class=string>"."</span> ) == str ) )
</pre>
</dl>
<p>
<hr><h3>Semantic changes in Lua 5.3.3</h3>
<p>
Up to Lua 5.3.2, splitting was tricky in most situations, because <code>string.gmatch</code> and <code>string.gsub</code> introduce spurious extra empty fields (as in Perl). From Lua 5.3.3 onwards, they no longer do that, they now behave as in Python. Therefore, the following minimalistic splitting function now is a true inverse of <code>table.concat</code>; previously it was not.
<p>
<dl>
<dt><dd><pre class=code><span class=comment>-- splits 'str' into pieces matching 'pat', returns them as an array</span>
<span class=keyword>local</span> <span class=keyword>function</span> split(str,pat)
   <span class=keyword>local</span> tbl = {}
   str:gsub(pat, <span class=keyword>function</span>(x) tbl[#tbl+1]=x <span class=keyword>end</span>)
   <span class=keyword>return</span> tbl
<span class=keyword>end</span>

<span class=keyword>local</span> str = <span class=string>"a,,b"</span>     <span class=comment>-- comma-separated list</span>
<span class=keyword>local</span> pat = <span class=string>"[^,]*"</span>    <span class=comment>-- everything except commas</span>
<span class=library>assert</span> (<span class=library>table.concat</span>(split(str, pat), <span class=string>","</span>) == str)
</pre>
</dl>
<p>
<a href=http://lua-users.org/wiki/DirkLaurie>DirkLaurie</a>
<p>
<hr><h3>Solving all performance problem caused by unanchored <code>'.-'</code> search patterns</h3>
The awful performance of the <code>'.-'</code> (non-greedy) pattern in the previous sections can be solved by anchoring it to the start position in the search string (the start position is not necessarily the first position in the string, if we use <code>string.find()</code> with its third parameter), so that the subpattern for matching the separator can be greedy (but note that if the separator is pattern that can match an empty string, an empty match will be found just before the start of the text, with an empty delimited string and an empty separator, so it could produce an infinite loop: don't specify any pattern for the separator that can match an empty string).
<p>
So to search the first separator <code>;</code> in string <code>str</code> from a starting position <code>p</code>, we can use:
<p>
<dl>
<dt><dd><pre class=code>q, r = str:find(<span class=string>'^.-;'</span>, p)
</pre>
</dl>
<p>
As well we don't need any capture to call <code>string.find()</code> when the separator is static: if there's a match q will be equal to p (because the pattern is anchored at start), and r will be just on the last character of the separator. As we can determine the length of the separator before the loop scanning the string to split with a simple <code>k = #sep</code> initialisation, the new delimited word will be <code>str:sub(q, r - k)</code>. But a static plain separator must first be transformed in the search pattern, by escaping its "magic characters" with a <code>'%'</code> prefix.
<p>
However if the separator must be a pattern, the effective separator found may have variable length, so you need to capture the text before the separator, and the full pattern to search is <code>('^(.-)' .. sep)</code>
<p>
<dl>
<dt><dd><pre class=code>q, r, s = str:find(<span class=string>'^(.-);'</span>, p)
</pre>
</dl>
<p>
If there's a match, <code>q</code> will be equal to the start position <code>p</code>, <code>r</code> will be the position of the last character of the separator (to be used for the next loop), and <code>s</code> will be the first capture, i.e. the word starting at position <code>p</code> (or <code>q</code>) but before the non-captured separator.
<p>
<p>
This gives the following efficent function:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>function</span> split(str, sep, plain, max)
    <span class=keyword>local</span> result, count, first, found, last, word = {}, 1, 1
    <span class=keyword>if</span> plain <span class=keyword>then</span>
        sep = sep:gsub(<span class=string>'[$%%()*+%-.?%[%]^]'</span>, <span class=string>'%%%0'</span>)
    <span class=keyword>end</span>
    sep = <span class=string>'^(.-)'</span> .. sep
    <span class=keyword>repeat</span>
        found, last, word = str:find(sep, first)
        <span class=keyword>if</span> q <span class=keyword>then</span>
            result[count], count, first = word, count + 1, last + 1
        <span class=keyword>else</span>
            result[count] = str:sub(first)
            <span class=keyword>break</span>
        <span class=keyword>end</span>
    <span class=keyword>until</span> count == max
    <span class=keyword>return</span> result
<span class=keyword>end</span>
</pre>
</dl>
<p>
Like the previous functions, you can pass an optional parameter <code>plain</code> set to true for searching a plain separator (that will be converted to a pattern), and a <code>max</code> parameter to limit the number of items in the returned array (if this limit is reached, the last delimited word returned does not contain any occurence of the separator, so the rest of the text is ignored in this implementation). Also note that empty strings delimited by separators may be returned (up to as many empty strings as there are occurences of separators found)
<p>
So:
<p>
<ul>
<li> <code> split(';;A', ';') </code> will return <code> {"", "", "A"} </code>
<li> <code> split(';;A', ';', true, 2) </code> will return <code> {"", ""} </code>
</ul>
<p>
The most compact splitting function that can be used with a plain separator (e.g. a <code>'\n'</code> newline with a single encoding, or a single <code>';'</code> semicolon, or a single <code>'\t'</code> tabulation control, or a longer sequence like <code>'--'</code>) is this one:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>local</span> <span class=keyword>function</span> splitByPlainSeparator(str, sep, max)
    <span class=keyword>local</span> z = #sep; sep = <span class=string>'^.-'</span>..sep:gsub(<span class=string>'[$%%()*+%-.?%[%]^]'</span>, <span class=string>'%%%0'</span>)
    <span class=keyword>local</span> t,n,p, q,r = {},1,1, str:find(sep)
    <span class=keyword>while</span> q <span class=keyword>and</span> n~=max <span class=keyword>do</span>
        t[n],n,p = s:sub(q,r-z),n+1,r+1
        q,r = str:find(sep,p)
    <span class=keyword>end</span>
    t[n] = str:sub(p)
    <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
The most compact splitting function that can be used with a pattern separator (e.g. a variable newline like <code>'\r?[\n\v\f]'</code> or any sequence of whitespace like <code>'%s+'</code>, or a comma optionally surrounded by greedy whitespaces like <code>'%s*,%s*'</code>) is this one:
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>local</span> <span class=keyword>function</span> splitByPatternSeparator(str, sep, max)
    sep = <span class=string>'^(.-)'</span>..sep
    <span class=keyword>local</span> t,n,p, q,r,s = {},1,1, str:find(sep)
    <span class=keyword>while</span> q <span class=keyword>and</span> n~=max <span class=keyword>do</span>
        t[n],n,p = s,n+1,r+1
        q,r,s = str:find(sep,p)
    <span class=keyword>end</span>
    t[n] = str:sub(p)
    <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
This last function however still does not support separators that can be one of several alternatives (because Lua has no <code>|</code> in its patterns), but you can circumvent this limitation by using several patterns, and using <code>str:find()</code> in an innner subloop to locate each possible alternative and take the minimum position found, using a small loop on each alternative pattern (for example to split with the extended pattern <code>'\r?\n|\r|&lt;br%s*/?&gt;'</code>):
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>local</span> <span class=keyword>function</span> splitByExtendedPatternSeparator(str, seps, max)
    <span class=comment>-- Split the extended pattern into a sequence of Lua patterns, using the function defined above.</span>
    <span class=comment>-- Note: '|' cannot be part of any subpattern alternative for the separator (no support here for any escape).</span>
    <span class=comment>-- Alternative: just pass "seps" as a sequence of standard Lua patterns built like below, with a non-greedy</span>
    <span class=comment>-- pattern anchored at start for the contextual text accepted in the returned texts betweeen separators,</span>
    <span class=comment>-- and the empty capture '()' just before the pattern for a single separator.</span>
    <span class=keyword>if</span> <span class=library>type</span>(seps) == <span class=string>'string'</span> <span class=keyword>then</span>
        seps = splitByPlainSeparator(sep, <span class=string>'|'</span>)
        <span class=comment>-- Adjust patterns</span>
        <span class=keyword>for</span> i, sep <span class=keyword>in</span> <span class=library>ipairs</span>(seps) <span class=keyword>do</span>
            seps[i] = <span class=string>'^.-()'</span> .. sep
        <span class=keyword>end</span>
    <span class=keyword>end</span>
    <span class=comment>-- Now the actual loop to split the first string parameter</span>
    <span class=keyword>local</span> t, n, p = {}, 1, 1
    <span class=keyword>while</span> n ~= max <span class=keyword>do</span>
        <span class=comment>-- locate the nearest subpatterns that match a separator in str:sub(p);</span>
        <span class=comment>-- if two subpatterns match at same nearest position, keep the longest one</span>
        <span class=keyword>local</span> first, last = <span class=keyword>nil</span>
        <span class=keyword>for</span> i, sep <span class=keyword>in</span> <span class=library>ipairs</span>(seps) <span class=keyword>do</span>
            <span class=keyword>local</span> q, r, s = str:find(sep, p)
            <span class=keyword>if</span> q <span class=keyword>then</span>
                <span class=comment>-- A possible separator (not necessarily the neareast) was found in str:sub(s, r)</span>
                <span class=comment>-- Here: q~=nil, r~=nil, s~=nil, q==p &lt;= s &lt;= r)</span>
                <span class=keyword>if</span> <span class=keyword>not</span> first <span class=keyword>or</span> s &lt; first <span class=keyword>then</span>
                   first, last = s, r <span class=comment>-- this also overrides any longer pattern, but located later</span>
                <span class=keyword>elseif</span> r &gt; last <span class=keyword>then</span>
                   last = r <span class=comment>-- prefer the longest pattern at the same position</span>
                <span class=keyword>end</span>
            <span class=keyword>end</span>
        <span class=keyword>end</span>
        <span class=keyword>if</span> <span class=keyword>not</span> first <span class=keyword>then</span> <span class=keyword>break</span> <span class=keyword>end</span>
        <span class=comment>-- the nearest separator (with the longest length) was found in str:sub(first, last)</span>
        t[n], n, p = str:sub(p, first - 1), n + 1, last + 1
    <span class=keyword>end</span>
    t[n] = str:sub(p)
    <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
These last three functions (nearly equivalent, but not exactly for the same purpose) both allow searching for all occurences of any separator (which is not limited to one character), they also have an optional <code>max</code> parameter (only used in the condition for a single <code>while</code> statement).:
<p>
<ul>
<li> if <code>max</code> is set to a positive integer larger than 1, then there will not be more than this number of substrings returned, the last one containing all the rest of the text (including separators), so it stops splitting after finding the <code>(max-1)</code> first occurences;
<li> if <code>max==1</code>, they both return the original text;
<li> if <code>max</code> is nil, or not an integer, or negative or zero, all separators will be scanned and the returned table will have <em>K</em>+1 string items if the source text contained <em>k</em> occurences of the separator, or will return a single string, identical to the input text if it contains no occurence at all of the separator.
<li> these functions do not test the types of parameters: <code>str</code> and <code>sep</code> are required and should both be strings not nil; but <code>max</code> is optional and to have an effect it should be a positive integer.
</ul>
<p>
If you never need the <code>max</code> parameter (i.e. behave like if it was <code>nil</code> above and so split the full text to remove all occurences of the plain or pattern separator), just remove the condition <code>and n~=max</code> in the first line of these <code>while</code> statements.
<p>
Note also that these functions above are stipping all the separators in the return table. You may want to have variable "separators" that you'll want to get a copy for different behavior. The modification is trivial: in the <code>while</code> loop of the 3 functions above, just append two strings instead of just one: the separated words will be at odd positions (starting from 1) in the returned table (which will have an add number of items), and the separators will be at even positions (starting from 2) if there's an occurence.
<p>
This allows creating a simple lexical parser, where "separators" (defined as an "extended pattern" like above or a table of patterns) will be the lexical tokens, and the "non-separators" will be the extra optional whitespaces, not matched by the tokens. In the sample code below, the extended pattern uses the null character (<code>'\000'</code> in Lua string litterals) instead of the pipe, to separate alternate subpatterns matching individual tokens.
<p>
<dl>
<dt><dd><pre class=code><span class=keyword>local</span> <span class=keyword>function</span> splitTokens(str, tokens, max)
    <span class=comment>-- Split the extended pattern into a sequence of Lua patterns, using the function defined above.</span>
    <span class=comment>-- Note: '\000' cannot be part of any subpattern alternative for the separator (no support here for any escape).</span>
    <span class=comment>-- Alternative: just pass "seps" as a sequence of standard Lua patterns built like below, with a non-greedy</span>
    <span class=comment>-- pattern anchored at start for the contextual text accepted in the returned texts betweeen separators,</span>
    <span class=comment>-- and the empty capture '()' just before the pattern for a single separator.</span>
    <span class=keyword>if</span> <span class=library>type</span>(tokens) == <span class=string>'string'</span> <span class=keyword>then</span>
        tokens = splitByPlainSeparator(tokens, <span class=string>'\000'</span>)
        <span class=comment>-- Adjust patterns</span>
        <span class=keyword>for</span> i, token <span class=keyword>in</span> <span class=library>ipairs</span>(tokens) <span class=keyword>do</span>
            tokens[i] = <span class=string>'^.-()'</span> .. token
        <span class=keyword>end</span>
    <span class=keyword>end</span>
    <span class=comment>-- Now the actual loop to split the first string parameter</span>
    <span class=keyword>local</span> t, n, p = {}, 1, 1
    <span class=keyword>while</span> n ~= max <span class=keyword>do</span>
        <span class=comment>-- locate the nearest subpatterns that match a separator in str:sub(p);</span>
        <span class=comment>-- if two subpatterns match at same nearest position, keep the longest one</span>
        <span class=keyword>local</span> first, last = <span class=keyword>nil</span>
        <span class=keyword>for</span> i, token <span class=keyword>in</span> <span class=library>ipairs</span>(tokens) <span class=keyword>do</span>
            <span class=keyword>local</span> q, r, s = str:find(token, p)
            <span class=keyword>if</span> q <span class=keyword>then</span>
                <span class=comment>-- A possible token (not necessarily the neareast) was found in str:sub(s, r)</span>
                <span class=comment>-- Here: q~=nil, r~=nil, s~=nil, q==p &lt;= s &lt;= r)</span>
                <span class=keyword>if</span> <span class=keyword>not</span> first <span class=keyword>or</span> s &lt; first <span class=keyword>then</span>
                   first, last = s, r <span class=comment>-- this also overrides any longer pattern, but located later</span>
                <span class=keyword>elseif</span> r &gt; last <span class=keyword>then</span>
                   last = r <span class=comment>-- prefer the longest pattern at the same position</span>
                <span class=keyword>end</span>
            <span class=keyword>end</span>
        <span class=keyword>end</span>
        <span class=keyword>if</span> <span class=keyword>not</span> first <span class=keyword>then</span> <span class=keyword>break</span> <span class=keyword>end</span>
        <span class=comment>-- The nearest token (with the longest length) was found in str:sub(first, last).</span>
        <span class=comment>-- Store the non-token part (possibly empty) at odd position, and the token at the next even position</span>
        t[n], t[n + 1], n, p = str:sub(p, first - 1), str:sub(first, last), n + 2, last + 1
    <span class=keyword>end</span>
    t[n] = str:sub(p) <span class=comment>-- Store the last non-token (possibly empty) at odd position</span>
    <span class=keyword>return</span> t
<span class=keyword>end</span>
</pre>
</dl>
<p>
So you can call this for example to tokenize a text containing identifiers, integers or floating point numbers (like those in the Lua syntax), or isolated non-space symbols (you can add tokens for longer symbols, or to support other literals, by adding more alternatives to the extended pattern):
<p>
<dl>
<dt><dd><pre class=code>splitTokens(str,
              <span class=string>'[%a_][%w_]+'</span> ..
    <span class=string>'\000'</span> .. <span class=string>'%d+[Ee][%-%+]?%d+'</span> ..
    <span class=string>'\000'</span> .. <span class=string>'%d+%.?%d*'</span> ..
    <span class=string>'\000'</span> .. <span class=string>'%.%d+[Ee][%-%+]?%d+'</span> ..
    <span class=string>'\000'</span> .. <span class=string>'%.%d+'</span> ..
    <span class=string>'\000'</span> .. <span class=string>'[^%w_%s]'</span>)
</pre>
</dl>
<p>
(verdy_p)
<p>
<hr><h3>Comparison to Other Languages</h3>
<p>
<ul>
<li> <a href=http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf>[7]</a> ECMA <a href=http://lua-users.org/wiki/JavaScript>JavaScript</a> "15.5.4.14 String.prototype.split (separator, limit)"
<li> <a href=http://perldoc.perl.org/functions/split.html>[8]</a> Perl split
<li> <a href=http://en.wikipedia.org/wiki/Comparison_of_programming_languages_%28string_functions%29#split>[9]</a> Wikipedia: Comparison of programming languages (string functions)§split
</ul>
<p>
<hr><h3>User Comments</h3>
<p>
<em>I mean no disrespect, of course, but.. does anyone actually have a working split function without glitches like infinite loops, wrong matches, or error cases? Are all those "takes" of any help here? -- <a href=http://lua-users.org/wiki/CosminApreutesei>CosminApreutesei</a></em>
<p>
<em>Try Rici Lake's split function: <a href=http://lua-users.org/lists/lua-l/2006-12/msg00414.html>LuaList:2006-12/msg00414.html</a> -- Jörg Richter</em>
<p>
<dl>
<dt><dd>That version fails again when the pattern is an empty string. Specifications for split functions in other languages define how these corner cases should behave (see "Comparison to Other Languages" above). --David Manura
</dl>
<p>
<hr><h3>See Also</h3>
<p>
<ul>
<li> (table.concat)<a href=http://www.lua.org/manual/5.1/manual.html#pdf-table.concat>[3]</a>
<li> <a href=http://lua-users.org/wiki/StringRecipes>StringRecipes</a>
<li> (An LPeg example "Splitting a String")<a href=http://www.inf.puc-rio.br/~roberto/lpeg.html#ex>[10]</a>.
<li> Split code by <a href=http://lua-users.org/wiki/RiciLake>RiciLake</a>: <a href=http://lua-users.org/lists/lua-l/2006-12/msg00414.html>LuaList:2006-12/msg00414.html</a>
<li> <a href=http://lua-users.org/wiki/MakingLuaLikePhp>MakingLuaLikePhp</a> (explode function)
</ul>
<hr>
<a href=http://lua-users.org/wiki/RecentChanges>RecentChanges</a> · <a href="http://lua-users.org/cgi-bin/wiki.pl?action=editprefs">preferences</a><br>
<a href="http://lua-users.org/cgi-bin/wiki.pl?action=edit&amp;id=SplitJoin">edit</a> · <a href="http://lua-users.org/cgi-bin/wiki.pl?action=history&amp;id=SplitJoin">history</a><br>Last edited June 2, 2020 10:42 pm GMT <a href="http://lua-users.org/cgi-bin/wiki.pl?action=browse&amp;diff=1&amp;id=SplitJoin">(diff)</a>
